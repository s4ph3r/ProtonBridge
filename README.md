<h1 align="center">Описание проекта</h1>

В далеком 2020 году в голову пришла идея купить за 1.5$ модуль BT4.0 AT-09 (с SOC CC2541 - на аналогичном камне сделан BT кусок AtomFast/Swift) и запилить из него мост UART - приложение AtomSwift, т.е. купив отладчик CC Debugger разработать собственную прошивку для него, описав BT профиль Atom. 
Корневая ветка форума - http://forum.rhbz.org/topic.php?forum=80&topic=98

В интернете гуляет инфа как при помощи обычной Arduino выполнить прошивку данного модуля без отладчика CC Debugger, поэтому данный проект может стать вполне народным, т.к. 1.5$ за такой модуль может себе позволить я думаю любой участник форума строящий самодельный дозиметр, или решивший модифицировать ДП-5 данным модулем + Arduino или другой МК, или прикрутив к самодельному спектрометру, сделав из него шустрый дозиметр с возможностью построения трека на карте в реальном времени при обследовании местности.

Для быстрой отладки был на скорою руку набросан софт под винду для генерирования рандомных, но приближенных к реальности данных и отправки их через преобразователь USB-UART в данный BT модуль.
На данный момент описана основная часть профиля Atom для вывода в приложение дозы, мощности дозы и прочих параметров описанных в основной измерительной характеристике, срисована схема модуля, что бы понимать что куда подключать, скриншоты реальной работы модуля см. ниже. ВПО модуля работает в прозрачном режиме - т.е. что пользователь отправил по UART , модуль эти данные передаст в нужном формате по BT в приложение.
Ну и если забыли приложение AtomSwift позволяет выводить трек на карты с привязкой по GPS/ГЛОНАСС.

Модуль на данный момент работает только в активном режиме (без сна) и жрет порядка 8мА.

По-сути осталось допилить правильный уход в сон, с выключением uart и правильное пробуждение с включением uart.

Для сборки использовать Embedded Workbench for 8051 version 10.30.

ЗЫ: для тех кто посчитает этот проект нелегальным - Madmax дал добро на сие использование его приложения.

<h1 align="center">Работа с модулем</h1>

Для записи данных в переменные модуля требуется:
1. отправить команду записи "0xA0";
2. отправить адрес переменной "0x02" - к примеру обновим мощность дозы;
3. отправляем данные согласно описания AtomService BLE размером 4 байта: "66E6F642" - к примеру мощность дозы равную "123,45 мкЗв/ч" (123,45(float) это в hex 0x42f6e666, ну и отправляем в порт начиная с младших байт 66 потом E6 потом F6 потом 42).
Итого требуется швырнуть в порт "A00266E6F642", думаю понятно.

Для чтения данных из переменных модуля требуется:
1. отправить команду чтения "0xB0";
2. отправить адрес переменной "0x02" - к примеру получим мощность дозы;
3. принять данные согласно описания AtomService BLE размером 4 байта: "66E6F642", соответственно положить данные в свою переменную нужно в обратном порядке, что бы получилось число 0x42f6e666, которое во float имеет значение 123,45.

Для новичков в программировании - отправка/прием должен осуществляться не в ASCII, а в двоичном формате(команды отправляются не текстом как в терминалах).

Описание адресов:

//Основная измерительная характеристика
0x00: //Флаги
0x01: //Накопленная доза в ​ mSv (миллизиверты)
0x02: //Мощность дозы в ​ µSv/h​ (микрозивертыв час)
0x03: //Число импульсов за последние 2 секунды
0x04: //Процент заряда батареи (0..100), %
0x05: //Температура (128..127), ºC

//Дополнительная измерительная характеристика (можно в нее не писать данные, приложение AtomSwift их не обрабатывает как я понял)
0x10: //Общее число импульсов
0x11: //Число импульсов коррекции на мёртвое время датчика
0x12: //Общее число импульсов за N секунд
0x13: //Время измерения дозы в секундах

//Характеристика настроек индикации превышения 1 порога
0x20: //Порог включения сигнала о превышении накопленной дозы
0x21: //Порог срабатывания сигнала о превышении мощности дозы
0x22: //Время детектирования превышения мощности дозы
0x23: //Байт управления виброзвуковой сигнализацией

//Характеристика настроек индикации превышения 2 порога
0x30: //Порог включения сигнала о превышении накопленной дозы
0x31: //Порог срабатывания сигнала о превышении мощности дозы
0x32: //Время детектирования превышения мощности дозы
0x33: //Байт управления виброзвуковой сигнализацией

//Характеристика настроек индикации превышения 3 порога
0x40: //Порог включения сигнала о превышении накопленной дозы
0x41: //Порог срабатывания сигнала о превышении мощности дозы
0x42: //Время детектирования превышения мощности дозы
0x43: //Байт управления виброзвуковой сигнализацией

//Характеристика управления устройством
0x50: //Команда, на чтение всегда 0x00
0x51: //Параметр #1
0x52: //Параметр #2
0x53: //Параметр #3

//Основная калибровочная характеристика
0x60: //Чувствительность датчика
0x61: //Фоновый счёт датчика
0x62: //Мертвое время датчика
0x63: //Время измерения мощности дозы
0x64: //Пароль для записи калибровки в RAM

//Характеристика служебных данных
0x70: //Команда, на чтение
0x71: //Параметры #1-#8

//Характеристика текстового описания
0x80: //Произвольная строка

Размерность и тип данных подробно описан в AtomService BLE. Выложена с согласия Максима.
В самом приложении AtomSwift принято за 1 мкЗв/ч = 100 мкР/ч, а не так как оговорено в AtomService BLE, соответственно в своем устройстве выполняйте аналогичный перевод 1:100.

Режим измерения
Есть небольшая тонкость в работе режима изменения. Приложение Atom Swift выполняет расчет в этом режиме исходя из накопленной дозы, соответственно ее нужно точно считать и слать модулю аналогично всем данным раз в секунду (чаще смысла нет, текущая версия прошивки, раз в секунду эти данные через уведомление отсылает приложению), более подробно как это работает - можно посмотреть запустив режим симуляции в тестовом приложении для винды. Если переменную накопленной дозы не обновлять, у вас приложение в режиме измерения будет вечно крутить мнемонику загрузки.

Выключение
В данный момент выключить/включить его можно только отключением/включением питания. Сон и вход EN ещё не реализован.



<h1 align="center">Порядок прошивки модуля AT-09 с использованием Arduino</h1>

1. Скачать из любого источника и установить Arduino IDE (я использовал портативную 1.8.11, скачанную https://amperka.ru/page/arduino-ide)
2. Скачать Arduino CCLoader https://github.com/RedBearLab/CCLoader
3. Залить в Arduino скетч CCLoader/CCLoader.ino
4. Скачать "srecord-1.63-win32" из "Tools" или отсюда - http://srecord.sourceforge.net/download.html
5. Копируем из папки "BLE-CC254x-1.5.1.1\Projects\ble\ProtonBridge\CC2541DB\CC2541\Exe" файл "ProtonBridgel.hex" в папку "srecord-1.63-win32"
6. Используя SRecord из папки Tools запускаем "convert hex to bin.bat" (или командой "srec_cat ProtonBridge.hex -Intel -o ProtonBridge.bin -Binary")
7. Открываем файл ProtonBridge.bin любым HEX редактором и добиваем "FF" конец файла до адреса "3FFFF" (примерно 138126 пустых байт, до итогового размера в 256кБ)
8. Соединить Arduino c модулем следующим образом:
- 4 порт Arduino к RESET_N модуля;
- 5 порт Arduino к P2.2 (DebugData) модуля;
- 6 порт Arduino к P2.1 (DebugClock) модуля;
- подключить землю GND и питание +3.3V в случае если модуль без переходной платы, или +5V если модуль с переходной печатной платой.
5. Открыть окно коммандной строки в окне с CCLoader.exe (правой кнопкой мыши с зажатым шифтом) и запустить прошивку следующей командой:
CCLoader.exe 9 ProtonBridge.bin 0
(9 это СОМ9, 0 это устройство по умолчанию - UNO)
Если висит на надписи Waiting for respond from Arduino - проверить правильность подключения, нажать ctrl+c и еще раз дать команду, софт бывает тупит даже при правильном подключении.
6. Модуль успешно прошит.

<img src="https://github.com/s4ph3r/ProtonBridge/blob/main/Info/Uno_flash_schematic.jpg"/>
<img src="https://github.com/s4ph3r/ProtonBridge/blob/main/Info/ccloader.jpg"/>
<img src="https://github.com/s4ph3r/ProtonBridge/blob/main/Info/Use_schematic.JPG"/>

USB-UART адаптер для проверки функционала модуля нужно использовать с уровнем единицы не более 3.6В! Либо делать схему согласования уровней, схем в сети куча. Я использовал свой универсальный сдвоенный преобразователь на FT2232.

